---
title: 设计模式-1
tags:
  - Android
  - 设计模式
categories: Android
date: 2018-01-24 16:06:02
---

## 简介

​	设计模式（Design pattern)代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

## 类型

​	设计模式总共23种。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。

#### 创建型模式

​	这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

- 工厂模式（Fatory Pattern）

- 抽象工厂模式（Abstract Fatory Pattern）

- 单例模式（Singleton Pattern）

- 建造者模式（Builder Pattern）

- 原型模式（Prototype Pattern）

#### 结构型模式
​	这些设计模式关注类和对象的组合。集成的概念被用来组合接口和定义组合对象获得新功能的方式。

- 适配器模式（Adapter Pattern）

- 桥接模式（Bridge Pattern）

- 过滤器模式（Filter、Criteria Pattern）

- 组合模式（Composite Pattern）

- 装饰器模式（Decorator Pattern）

- 外观模式（Facade Pattern）

- 享元模式（Flyweight Pattern）

- 代理模式（Proxy Pattern）

#### 行为型模式

  	这些设计模式特别关注对象之间的通信。

- 责任链模式（Chain of Responsibility Pattern）
- 命令模式（Command Pattern）
- 解释器模式（Interpreter Pattern）
- 迭代器模式（Iterator Pattern）
- 中介者模式（Mediator Pattern）
- 备忘录模式（Memento Pattern）
- 观察者模式（Observer Pattern）
- 状态模式（State Pattern)
- 空对象模式（Null Object Pattern）
- 策略模式（Strategy Pattern）
- 模板模式（Template Pattern）
- 访问者模式（Visitor Pattern）

## 常用的设计模式

#### 工厂模式

​	工厂模式（Factory Pattern）是java中最常用的设计模式之一。这种类型的模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

#### 单例模式

​	单例模式（Singleton Pattern）是java中最简单的设计模式之一。这种类型的设计模式属于创建性模式，它提供了一中创建对象的最佳方式。

​	这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

​	**单例的实现方式：**

1. 懒汉式，线程不安全

   ```java
   public class Singleton{
     
     private static Singleton instance;
     
     private Singleton(){}
     
     public static Singleton getInstance(){
       if( instance == null ){
         	instance = new Singleton();
       }
       return instance;
     }
     
   }
   ```

   ​	这种方式 lazy loading 很明显，不要去线程安全，在多线程不能正常工作。

2. 懒汉式，线程安全

   ```java
   public class Singleton{
     
     private static Singleton instance;
     
     private Singleton(){}
     
     public static synchronized Singleton getInstance(){
       if(instance == null){
          instance = new Singleton();
       }
       return instance;
     }
     
   }
   ```

   ​	这种方式具备很好的 lazy loading ，能够在多线程中很好的工作，但是，效率很低，99%情况下不需要同步。但是 getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。

3. 饿汉式

   ```java
   public class Singleton{
     
     private static Singleton instance = new Singleton();
     
     private Singleton (){}
     
     public static Singleton getInstance(){
       return instance;
     }
     
   }
   ```

   ​	它基于 classloader 机制避免了多线程的同步问题，不过， instance 在类装载是就实例化，这样无法达到 lazy loading 的效果。

4. 双检锁/双重校验锁

   ```java
   public class Singleton{
     
     private volatile static Singleton instance;
     
     private Singleton(){}
     
     public static Singleton getInstance(){
       if( instance ==null ){
         synchronized (Singleton.class){
           if( singleton == null ){
             	singleton = new Singleton();
           }
         }
       }
       return singleton;
     }
     
   }
   ```

   ​	这种法师采用双锁机制，安全且在多线程情况下能保持高性能。注意：volatile关键字是必须的。

5. 登记式/静态内部类

   ```java
   public class Singleton{
     
     private static class SingletonHolder{
       private static final Singleton INSTANCE = new Singleton();
     }
     
     private Singleton (){}
     
     public static final Singleton getInstance(){
       return SingletonHolder.INSTANCE;
     }
     
   }
   ```

   ​	这种方式能达到双检索方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检索方式。这种方式只适用于静态域的情况，双检索方式可在实例域需要延迟初始化时使用。

#### 观察者模式

​	当对象间存在一对多关系时，则使用观察者模式（Observer Pattern)。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。

