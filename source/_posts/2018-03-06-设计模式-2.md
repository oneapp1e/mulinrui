---
title: 设计模式-2
tags:
  - Android
  - 设计模式
categories: Android
date: 2018-03-06 16:43:38
---

## 前言

​        上一篇文章已经简单的介绍了设计模式的概念，今天再新介绍几个设计模式，并对之前介绍的设计模式进行一个补充。

​       目前大家常用的都是创建型的设计模式，单例模式使用最多最广，上一篇已经介绍的很清楚了，今天着重介绍一下其他的几种创建型的设计模式。

## 工厂模式

​        工厂模式（Factory Pattern）是java中最常用的设计模式之一。这种类型的模式属于创建型模式，它提供了一种创建对象的最佳方式。

​        在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

#### 简单工厂模式

​        简单工厂模式（simple Factory Pattern）：又称为静态工厂方法，再简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。使用场景：BitmapFactory.decodeResource()。

**简单工厂包含以下角色：**

- **Factory：工厂角色**

  工厂角色负责实现创建所有实例的内部逻辑

- **Product：抽象产品角色**

  抽象产品角色是所创建的所有对象的父类，负责描述所有对象所共有的公共接口

- **ConcreteProduct：具体产品角色**

  具体产品角色是创建的目标，所有创建的对象都充当这个角色的某个具体类的实例。

  ![简单工厂模式](https://ws1.sinaimg.cn/large/6a7720d1ly1fp34yrdj1ej20og0g10ul.jpg)

#### 工厂方法模式

​        工厂方法模式Factory Method Pattern又称为多态工厂模式，在工厂方法中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，既通过工厂子类来确定究竟应该实例化哪一个具体产品类。使用场景：ArrayList

**工厂方法模式角色：**

- **Product：抽象产品**
- **ConcreteProduct：具体产品**
- **Factory：抽象工厂**
- **ConcreteFactory：具体工厂**

![工厂方法模式](https://ws1.sinaimg.cn/large/6a7720d1ly1fp35c8h37bj20nk0b8abo.jpg)

#### 抽象工厂模式

 抽象工厂模式Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。抽象工厂是简单工厂和工厂方法的组合体。工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品登记结构，一个等级结构可以负责多个不同产品等级结构中的产品对象的创建。使用场景：MediaPlayerFactory.cpp

**抽象工厂模式角色**

- AbstractFactory：抽象工厂

- ConcreteFactory：具体工厂

- AbstractProduct：抽象产品

- Product：具体产品

  [![抽象工厂模式类图](https://ws1.sinaimg.cn/large/6a7720d1ly1fp35lsg5vlj20r10hj0um.jpg)](https://ws1.sinaimg.cn/large/6a7720d1ly1fp35lsg5vlj20r10hj0um.jpg)

## 原形模式

​        原形模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计属于创建型模式，它提供了一种创建对象的最佳方式。

​        这种模式是实现了一个原形接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。应用场景：java经典Object 的clone()方法。

## 建造者模式

​        建造者模式（Builder Pattern）使用多个简单的对象一步一步的构建成一个复杂的对象。它提供了一种创建对象的最佳方式。

​        一个Builder类会一步一步构造最终的对象。

​        该模式的应用场景也是很多：AlertDialog.Builder，以及常用的各种框架中。

## 总结

​        前后两篇文章基本介绍的创建型模式，也是常用的设计模式，在日常开发中或看系统源码中，这些设计模式随处可见。